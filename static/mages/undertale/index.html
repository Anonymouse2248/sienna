<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/yellowdevelopmnt/jsdelivr-cdns/undertale/favicon.png">
    <title>UNDERTALE</title>
    <style>
      @-webkit-keyframes rotation {
        from { -webkit-transform: rotate(0deg); }
        to { -webkit-transform: rotate(360deg); }
      }
      @-moz-keyframes rotation {
        from { -moz-transform: rotate(0deg); }
        to { -moz-transform: rotate(360deg); }
      }
      @-o-keyframes rotation {
        from { -o-transform: rotate(0deg); }
        to { -o-transform: rotate(360deg); }
      }
      @keyframes rotation {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }

      html {
        background: #000;
      }

      body {
        font-family: arial;
        margin: 0;
        padding: 0;
        min-height: 100vh;
        min-width: 100vw;
        background-color: black;
        display: flex;
        flex-direction: column;
        overflow-x: hidden;
        place-items: center;
      }

      .emscripten {
        padding-right: 0;
        display: block;
      }

      div.emscripten {
        text-align: center;
        font-family: "Lucida Console", Monaco, monospace;
      }

      canvas.emscripten {
        display: none;
        background-color: black;
        position: flex;
        transition: opacity 5s ease-in;
        opacity: 0;
        image-rendering: pixelated;
      }

      canvas.active {
        animation-name: fadeIn;
        animation-duration: 2s;
        opacity: 1;
      }

      canvas.paused {
        animation-name: blur;
        animation-duration: 0.5s;
        filter: blur(2px) grayscale(1);
      }

      @keyframes fadeIn {
        0% { opacity: 0; }
        100% { opacity: 1; }
      }

      @keyframes blur {
        0% { filter: blur(0) grayscale(0); }
        100% { filter: blur(2px) grayscale(1); }
      }

      .spinner {
        height: 30px;
        width: 30px;
        animation: rotation 0.8s linear infinite;
        border: 5px solid #bdff00;
        border-top: 5px solid #719900;
        border-radius: 100%;
      }

      #status {
        display: inline-block;
        vertical-align: top;
        font-weight: bold;
        color: white;
      }

      progress[value]::-webkit-progress-bar {
        background-color: #8492a6;
        height: 10px;
        border-radius: 15px;
      }

      progress[value]::-webkit-progress-value {
        background-image: -webkit-linear-gradient(left, #719900, #bdff00);
        height: 10px;
        border-radius: 15px;
      }

      div.loading {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        pointer-events: none;
      }

      div.loading > * {
        padding: 10px;
        margin: 10px;
      }
    </style>
  </head>

  <body>
    <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" tabindex="-1"></canvas>

    <div class="loading">
      <div class="spinner" id="spinner"></div>
      <div class="emscripten" id="status">Downloading Files, This Might Take A Moment... SIENNA</div>
      <progress value="0" max="100" id="progress" hidden></progress>
    </div>

    <script>
      // Merge split data files into one blob
      function mergeFiles(fileParts) {
        return new Promise((resolve, reject) => {
          const buffers = [];
          function fetchPart(i) {
            if (i >= fileParts.length) {
              const mergedBlob = new Blob(buffers);
              const mergedFileUrl = URL.createObjectURL(mergedBlob);
              resolve(mergedFileUrl);
              return;
            }
            fetch(fileParts[i])
              .then(r => r.arrayBuffer())
              .then(d => {
                buffers.push(d);
                fetchPart(i + 1);
              })
              .catch(reject);
          }
          fetchPart(0);
        });
      }

      function getParts(file, start, end) {
        const parts = [];
        for (let i = start; i <= end; i++) parts.push(`${file}.part${i}`);
        return parts;
      }

      mergeFiles(getParts("https://cdn.jsdelivr.net/gh/yellowdevelopmnt/jsdelivr-cdns/undertale/game.unx", 1, 7)).then(url => {
        window.gameUnxUrl = url;

        // Intercept fetch and XHR for the merged file
        const originalFetch = window.fetch;
        window.fetch = async (...args) => {
          let [url, options] = args;
          if (typeof url === "string" && url.includes("game.unx")) {
            url = window.gameUnxUrl;
          } else if (url instanceof Request && url.url.includes("game.unx")) {
            url = new Request(window.gameUnxUrl, url);
          }
          return originalFetch.call(this, url, options);
        };

        const originalOpen = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function (method, url, ...rest) {
          if (url.includes("game.unx")) {
            url = window.gameUnxUrl;
          }
          return originalOpen.call(this, method, url, ...rest);
        };

        // Load scripts from CDN
        const index = document.createElement("script");
        index.src = "index.js";
        document.body.appendChild(index);

        const runner = document.createElement("script");
        runner.src = "https://cdn.jsdelivr.net/gh/yellowdevelopmnt/jsdelivr-cdns/undertale/runner.js";
        document.body.appendChild(runner);

        // Add error handling for visibility changes
        document.addEventListener("visibilitychange", (event) => {
          try {
            if (document.visibilityState !== "visible") {
              // Only call pause if it exists and canvas is active
              if (typeof pause === "function" && document.getElementById("canvas")?.classList.contains("active")) {
                pause();
              }
            }
          } catch (error) {
            console.warn("Error handling visibility change:", error);
          }
        });

        // Add error handling for window focus/blur
        window.addEventListener("blur", (event) => {
          try {
            if (typeof pause === "function" && document.getElementById("canvas")?.classList.contains("active")) {
              pause();
            }
          } catch (error) {
            console.warn("Error handling window blur:", error);
          }
        });

        window.addEventListener("focus", (event) => {
          try {
            if (typeof resume === "function" && document.getElementById("canvas")?.classList.contains("active")) {
              resume();
            }
          } catch (error) {
            console.warn("Error handling window focus:", error);
          }
        });

      }).catch(err => {
        console.error("Failed to merge files:", err);
      });

      // Global error handler to catch any unhandled exceptions
      window.addEventListener("error", (event) => {
        console.error("Global error caught:", event.error);
        // Prevent the error from showing in the UI
        event.preventDefault();
        return true;
      });

      // Handle unhandled promise rejections
      window.addEventListener("unhandledrejection", (event) => {
        console.error("Unhandled promise rejection:", event.reason);
        event.preventDefault();
      });
    </script>
  </body>
</html>
